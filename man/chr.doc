\chapter{CHR: Constraint Handling Rules} 		\label{sec:chr}

This chapter is written by Tom Schrijvers, K.U. Leuven for the hProlog
system. Adjusted by Jan Wielemaker to fit the SWI-Prolog documentation
infrastructure and remove hProlog specific references.

The CHR runtime environment using in SWI-Prolog is written by Christian
Holzbaur and Tom Schrijvers while the compiler is written by Tom
Schrijvers.  Both are integrated with SWI-Prolog and licenced under
compatible conditions with permission from the authors.


\section{Introduction}
%=====================

Constraint Handling Rules (CHR) is a committed-choice bottom-up language
embedded in Prolog. It is designed for writing constraint solvers and is
particularily useful for providing application-specific constraints.
It has been used in many kinds of applications, like scheduling,
model checking, abduction, type checking among many others.

CHR has previously been implemented in other Prolog systems (SICStus,
Eclipse, Yap), Haskell and Java. This CHR system is based on the
compilation scheme and runtime environment of CHR in SICStus.

In this documentation we restrict ourselves to giving a short overview
of CHR in general and mainly focus on elements specific to this
implementation. For a more thorough review of CHR we refer the reader to
\cite{Freuhwirth:98}. More background on CHR can be found at
\cite{chrSite}.

In \secref{SyntaxAndSemantics} we present the syntax of CHR in Prolog and
explain informally its operational semantics. Next, \secref{practical}
deals with practical issues of writing and compiling hProlog programs
containing CHR. \Secref{debugging} explains the currently primitive CHR
debugging facilities. \Secref{predicates} provides a few useful predicates
to inspect the constraint store and \secref{examples} illustrates CHR with
two example programs. In \secref{sicstus-chr} some compatibility issues with
SICStus CHR are listed. Finally, \secref{guidelines} concludes with a few
practical guidelines for using CHR.


\section{Syntax and Semantics} 		\label{sec:SyntaxAndSemantics}
%=============================

\subsection{Syntax}
%-----------------

The syntax of CHR rules in hProlog is the following:

\begin{code}
rules --> rule, rules.
rules --> [].

rule --> name, actual_rule, pragma, [atom('.')].

name --> atom, [atom('@')].
name --> [].

actual_rule --> simplification_rule.
actual_rule --> propagation_rule.
actual_rule --> simpagation_rule.

simplification_rule --> constraints, [atom('<=>')], guard, body.
propagation_rule --> constraints, [atom('==>')], guard, body.
simpagation_rule --> constraints, [atom('\')], constraints, [atom('<=>')], 
                     guard, body.

constraints --> constraint, constraint_id.
constraints --> constraint, [atom(',')], constraints.

constraint --> compound_term.

constraint_id --> [].
constraint_id --> [atom('#')], variable.

guard --> [].
guard --> goal, [atom('|')].

body --> goal.

pragma --> [].
pragma --> [atom('pragma')], actual_pragmas.

actual_pragmas --> actual_pragma.
actual_pragmas --> actual_pragma, [atom(',')], actual_pragmas.

actual_pragma --> [atom('passive(')], variable, [atom(')')].

\end{code}

Additional syntax-related terminology:

\begin{itemize}
\item \textbf{head:} the constraints in an \texttt{actual_rule} before
                     the arrow (either \texttt{<=>} or \texttt{==>})
\end{itemize}

\subsection{Semantics}
%--------------------

In this subsection the operational semantics of CHR in Prolog are presented
informally. They do not differ essentially from other CHR systems.

When a constraint is called, it is considered an active constraint and
the system will try to apply the rules to it. Rules are tried and executed
sequentially in the order they are written. 

A rule is conceptually tried for an active constraint in the following
way. The active constraint is matched with a constraint in the head of
the rule. If more constraints appear in the head they are looked for
among the suspended constraints, which are called passive constraints in
this context. If the necessary passive constraints can be found and all
match with the head of the rule and the gaurd of the rule succeeds, then
the rule is committed and the body of the rule executed. If not all the
necessary passive constraint can be found, the matching fails or the
guard fails, then the body is not executed and the process of trying and
executing simply continues with the following rules. If for a rule,
there are multiple constraints in the head, the active constraint will
try the rule sequentially multiple times, each time trying to match with
another constraint.

This process ends either when the active constraint disappears, i.e.\ it
is removed by some rule, or after the last rule has been processed. In
the latter case the active constraint becomes suspended.

A suspended constraint is eligible as a passive constraint for an active
constraint. The other way it may interact again with the rules, is when
a variable appearing in the constraint becomes bound to either a nonvariable
or another variable involved in one or more constraints. In that case the
constraint is triggered, i.e.\ it becomes an active constraint and all
the rules are tried.

\paragraph{Rule Types}
%- - - - - - - - - - 

There are three different kinds of rules, each with their specific semantics:

\begin{itemlist}
    \item [simplification]
The simplification rule removes the constraints in its head and calls its body.

    \item [propagation]
The propagation rule calls its body exactly once for the constraints in
its head.

    \item [simpagation]
The simpagation rule removes the constraints in its head after the
$\backslash$ and then calls its body. It is an optimization of
simplification rules of the form: \[constraints_1, constraints_2 <=>
constraints_1, body \] Namely, in the simpagation form: \[ constraints_1
\backslash constraints_2 <=> body \] The \arg{constraints_1}
constraints are not called in the body.
\end{itemlist}

\paragraph{Rule Names}
%- - - - - - - - - - 
Naming a rule is optional and has no semantical meaning. It only functions
as documentation for the programmer.

\paragraph{Pragmas}
%- - - - - - - - -
The semantics of the pragmas are:

\begin{description}
    \termitem{passive}{Identifier}
The constraint in the head of a rule \arg{Identifier} can only act as a
passive constraint in that rule.
\end{description}

Additional pragmas may be released in the future.

\paragraph{Options}
%- - - - - - - - -
It is possible to specify options that apply to all the CHR rules in the module.
Options are specified with the \texttt{option/2} declaration:

\begin{code}
                option(Option,Value).
\end{code}

Available options are:
\begin{description}
        \termitem{check_guard_bindings}{}
This option controls whether guards should be checked for illegal variable bindings
or not.
Possible values for this option are \texttt{on}, to enable the checks, and \texttt{off}, 
to disable the checks.
        \termitem{optimize}{}
This is an experimental option controlling the degree of optimization. Possible values are
\texttt{full}, to enable all available optimizations, and \texttt{off}, to disable all optimizations.
	\termitem{debug}{}
This options enables or disables the possibility to debug the CHR code.
Possible values are \texttt{on} and \texttt{off} (default). See
\secref{debugging} for more details on debugging.
\end{description}

\section{CHR in SWI-Prolog Programs}		\label{sec:practical}
%===========================

\subsection{Embedding in Prolog Programs}

The CHR constraints defined in a particulary \fileext{chr} file are
associated with a module. The default module is \const{user}. One should
never load different \fileext{chr} files with the same CHR module name.

\subsection{Compilation}

A \fileext{chr} file containing CHR rules can be compiled and loaded
like any other \fileext{pl} file after loading the library module
\pllib{chr}:

\begin{code}
:- use_module(library(chr)).
:- ['Tests/zebra.chr'].
% Translating CHR file zebra.chr
% Written translation to zebra.pl
% /staff/jan/src/pl/packages/chr/Tests/zebra.pl compiled into zebra 0.01 sec, 20,984 bytes
\end{code}

\paragraph{Note}

When compiling a \fileext{chr} file, it is preprocessed and a
\texttt{.pl} file is generated. This \fileext{pl} file should not be
modified. All changes should be applied to the \fileext{chr} file.

\section{Debugging}			\label{sec:debugging}
%=================

The CHR debugging facilities are currently rather limited. Only
tracing is currently available.

\subsection{Requirement}
%=====================

In order to use the CHR debugging facilities for a CHR file,
it is necessary to enable the \texttt{debug} option by
writing:
\begin{verbatim}
	:- option(debug,on).
\end{verbatim}
in the \fileext{chr} file.

When the \texttt{debug} option is not enabled, the debugging
facilities are not available for that file.

\subsection{Ports}
%===============

For CHR constraints the four standard ports are defined:

\begin{itemlist}
	\termitem{call}{}
A new constraint is called and becomes active.
	\termitem{exit}{}
An active constraint exits: it has either been inserted in the store after
trying all rules or has been removed from the constraint store.
	\termitem{fail}{}
An active constraint fails.
	\termitem{redo}{}
An active constraint starts looking for an alternative solution.
\end{itemlist}

In addition to the above ports, CHR constraints have five additional
ports:

\begin{itemlist}
	\termitem{wake}{}
A suspended constraint is woken and becomes active.
	\termitem{insert}{}
An active constraint has tried all rules and is suspended in
the constraint store.
	\termitem{remove}{}
An active or passive constraint is removed from the constraint
store, if it had been inserted.
\termitem{try}{}
	An active constraints tries a rule with possibly
	some passive constraints. The try port is entered
	just before committing to the rule.
\termitem{apply}{}
	An active constraints commits to a rule with possibly
	some passive constraints. The apply port is entered
	just after committing to the rule.
\end{itemlist}

\subsection{Tracing}
%=================

Tracing is enabled with the \predref{chr_trace}{0} predicate
and disabled with the \predref{chr_notrace}{0} predicate.

When enabled the tracer will step through
the \texttt{call}, \texttt{exit}, \texttt{fail}, \texttt{wake}
and \texttt{apply} ports, accepting debug commands,
and simply write out the other ports.

The following debug commans are currently supported:

\begin{verbatim}
        CHR debug options:

                <cr>    creep           c       creep
		s	skip
		g	ancestors
                n       nodebug
                a       abort
                f       fail
                ?       help            h       help
\end{verbatim}

Their meaning is:

\begin{itemlist}
	\termitem{creep}{}
Step to the next port.
	\termitem{skip}{}
Skip to exit port of this call or wake port.
	\termitem{ancestors}
Print list of ancestor call and wake ports.
	\termitem{nodebug}{}
Disable the tracer.
	\termitem{abort}{}
Exit to the toplevel.
	\termitem{fail}{}
Insert failure in execution.
	\termitem{help}{}
Print the above available debug options.
\end{itemlist}

\section{Useful Predicates} 		\label{sec:predicates}
%=========================

The \pllib{chr} module contains several useful predicates that
allow inspecting and printing the content of the constraint store.

\begin{description}
    \predicate{chr_show_store}{1}{+Mod}
Prints all suspended constraints of module \arg{Mod} to the
standard output.
\end{description}


\section{Examples}			\label{sec:examples}
%================

Here are two example constraint solvers written in CHR.

\begin{itemize}
    \item
The program below defines a solver with one constraint, 
\predref{leq}{2}, which is a less-than-or-equal constraint.

\begin{code}
:- module(leq,[cycle/3, leq/2]).

:- constraints leq/2.
reflexivity  @ leq(X,X) <=> true.
antisymmetry @ leq(X,Y), leq(Y,X) <=> X = Y.
idempotence  @ leq(X,Y) \ leq(X,Y) <=> true.
transitivity @ leq(X,Y), leq(Y,Z) ==> leq(X,Z).

cycle(X,Y,Z):-
        leq(X,Y),
        leq(Y,Z),
        leq(Z,X).
\end{code}

    \item
The program below implements a simple finite domain
constraint solver.

\begin{code}
:- module(dom,[dom/2]).

:- constraints dom/2. 

dom(X,[]) <=> fail.
dom(X,[Y]) <=> X = Y.
dom(X,L1), dom(X,L2) <=> intersection(L1,L2,L3), dom(X,L3).

intersection([],_,[]).
intersection([H|T],L2,[H|L3]) :-
        member(H,L2), !,
        intersection(T,L2,L3).
intersection([_|T],L2,L3) :-
        intersection(T,L2,L3).
\end{code}
		
\end{itemize}

\section{Compatibility with SICStus CHR} 		\label{sec:sicstus-chr}
%==================

There are small differences between CHR in SWI-Prolog and SICStus.
Besides differences in available options and pragmas, the following
differences should be noted:

\begin{itemlist}
        \item [The \predref{handler}{1} declaration]
In SICStus every CHR module requires a \predref{handler}{1}
declaration declaring a unique handler name. This declaration is valid
syntax in SWI-Prolog, but will have no effect. A warning will be given
during compilation.

        \item [The \predref{rules}{1} declaration]
In SICStus every CHR it is possible to only enable a subset of the
available rules through the \predref{rules}{1} declaration. The
declaration is valid syntax in SWI-Prolog, but will have no effect. A
warning will be given during compilation.
\end{itemlist}


\section{Guidelines} 			\label{sec:guidelines}
%==================

In this section we cover several guidelines on how to use CHR to write
constraint solvers and how to do so efficiently.

\begin{itemlist}
    \item [Set semantics]
The CHR system allows the presence of identical constraints, i.e.
multiple constraints with the same functor, arity and arguments. For
most constraint solvers, this is not desirable: it affects efficiency
and possibly termination. Hence appropriate simpagation rules should be
added of the form: \[ constraint \backslash constraint <=> true \]

    \item [Multi-headed rules]
Multi-headed rules are executed more efficiently when the constraints
share one or more variables.
\end{itemlist}
