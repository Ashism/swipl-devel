\chapter{Hackers corner}			\label{sec:hack}

This appendix describes a number of predicates which enable the Prolog
user to inspect the Prolog environment and manipulate (or even redefine)
the debugger.  They can be used as entry points for experiments with
debugging tools for Prolog. The predicates described here should be
handled with some care as it is easy to corrupt the consistency of the
Prolog system by misusing them.

\section{Examining the Environment Stack}	\label{sec:manipstack}

\begin{description}
    \predicate{prolog_current_frame}{1}{-Frame}
Unify \arg{Frame} with an integer providing a reference to the parent of
the current local stack frame.  A pointer to the current local frame
cannot be provided as the predicate succeeds deterministically and
therefore its frame is destroyed immediately after succeeding.

    \predicate{prolog_frame_attribute}{3}{+Frame, +Key, -Value}
Obtain information about the local stack frame \arg{Frame}.  \arg{Frame}
is a frame reference as obtained through prolog_current_frame/1, 
prolog_trace_interception/4 or this predicate.  The key values are
described below.

\begin{description}
    \termitem{alternative}{}
\arg{Value} is unified with an integer reference to the local stack
frame in which execution is resumed if the goal associated with
\arg{Frame} fails. Fails if the frame has no alternative frame.

    \termitem{has_alternatives}{}
\arg{Value} is unified with \const{true} if \arg{Frame} still is a
candidate for backtracking. \const{false} otherwise.

    \termitem{goal}{}
\arg{Value} is unified with the goal associated with \arg{Frame}. If the
definition module of the active predicate is not \const{user} the goal
is represented as \mbox{\tt <module>:<goal>}. Do not instantiate
variables in this goal unless you {\bf know} what you are doing!
Note that the returned term may contain references to the frame and
should be discarded before the frame terminates.%
	\footnote{The returned term is actually an illegal Prolog term
		  that may hold references from the global- to the local
		  stack to preserve the variable names.}

    \termitem{parent_goal}{}
If \arg{Value} is instantiated to a callable term, find a frame
executing the predicate described by \arg{Value} and unify the arguments
of \arg{Value} to the goal arguments associated with the frame. This is
intended to check the current execution context. The user must ensure
the checked parent goal is not removed from the stack due to last-call
optimisation and be aware of the slow operation on deeply nested calls.

    \termitem{clause}{}
\arg{Value} is unified with a reference to the currently running clause.
Fails if the current goal is associated with a foreign (C) defined
predicate. See also nth_clause/3 and clause_property/2.

    \termitem{level}{}
\arg{Value} is unified with the recursion level of \arg{Frame}. The top
level frame is at level `0'.

    \termitem{parent}{}
\arg{Value} is unified with an integer reference to the parent local
stack frame of \arg{Frame}. Fails if \arg{Frame} is the top frame.

    \termitem{context_module}{}
\arg{Value} is unified with the name of the context module of the
environment.

    \termitem{top}{}
\arg{Value} is unified with \const{true} if \arg{Frame} is the top Prolog
goal from a recursive call back from the foreign language. \const{false}
otherwise.

    \termitem{hidden}{}
\arg{Value} is unified with \const{true} if the frame is hidden from the
user, either because a parent has the hide-childs attribute (all system
predicates), or the system has no trace-me attribute.

    \termitem{pc}{}
\arg{Value} is unified with the program-pointer saved on behalve of the
parent-goal if the parent-goal is not owned by a foreign predicate.

    \termitem{argument}{N}
\arg{Value} is unified with the \arg{N}-th slot of the frame. Argument
1 is the first argument of the goal. Arguments above the arity
refer to local variables. Fails silently if \arg{N} is out of range.
\end{description}

    \predicate{prolog_choice_attribute}{3}{+ChoicePoint, +Key, -Value}
Extract attributes of a choice-point.  \arg{ChoicePoint} is a reference
to a choice-point as passed to prolog_trace_interception/4 on the 3-th
argument.  \arg{Key} specifies the requested information:

\begin{description}
    \termitem{parent}{}
Requests a reference to the first older choice-point.
    \termitem{frame}{}
Requests a reference to the frame to which the choice-point refers.
    \termitem{type}{}
Requests the type.  Defined values are \const{clause} (the goal has
alternative clauses), \const{foreign} (non-deterministic foreign
predicate), \const{jump} (clause internal choicepoint), \const{top}
(first dummy choice-point), \const{catch} (catch/3 to allow for undo),
\const{debug} (help the debugger), or \const{none} (has been deleted).
\end{description}

This predicate is used for the graphical debugger to show the
choicepoint stack.

    \predicate{deterministic}{1}{-Boolean}
Unifies its argument with \const{true} if the clause in which is appears
has not created any choicepoints since it was started.  There are few
realistic situations for using this predicate. It is used by the
prolog/0 toplevel to check whether Prolog should prompt the user for
alternatives.
\end{description}


\section{Intercepting the Tracer}		\label{sec:tracehook}

\begin{description}
    \predicate{prolog_trace_interception}{4}{+Port, +Frame, +Choice, -Action}
Dynamic predicate, normally not defined. This predicate is called from
the SWI-Prolog debugger just before it would show a port. If this
predicate succeeds the debugger assumes the trace action has been taken
care of and continues execution as described by \arg{Action}. Otherwise
the normal Prolog debugger actions are performed.

\arg{Port} denotes the reason to activate the tracer (`port' in the
4/5-port, but with some additions:

\begin{description}
    \termitem{call}{}
Normal extry through the call-port of the 4-port debugger.

    \termitem{redo}{}
Normal extry through the call-port of the 4-port debugger. The
\const{redo} port signals resuming a predicate to generate alternative
solutions.

    \termitem{unify}{}
The unify-port represents the \jargon{neck} instruction, signalling the
end of the head-matching process.  This port is normally unvisible.  See
leash/1 and visible/1.

    \termitem{exit}{}
The exit-port signals the goal is proved.  It is possible for the goal
to have alternative. See prolog_frame_attribute/3 to examine the
goal-stack.

    \termitem{fail}{}
The fail-port signals final failure of the goal.

    \termitem{exception}{Except}
An exception is raised and still pending.  This port is activated on
each parent frame of the frame generating the exception until the
exception is caught or the user restarts normal computation using
\const{retry}.  \arg{Except} is the pending exception-term.

    \termitem{break}{PC}
A \const{break} instruction is executed.  \arg{PC} is program counter.
This port is used by the graphical debugger.

    \termitem{cut_call}{PC}
A cut is encountered at \arg{PC}. This port is used by the graphical
debugger. to visualise the effect of the cut.

    \termitem{cut_exit}{PC}
A cut has been executed.  See \term{cut_call}{PC} for more information.
\end{description}

\arg{Frame} is a reference to the current local stack frame, which can
be examined using prolog_frame_attribute/4. \arg{Choice} is a reference
to the last choice-point and can be examined using
prolog_choice_attribute/3. \arg{Action} should be unified with one of
the atoms \const{continue} (just continue execution), \const{retry}
(retry the current goal) or \const{fail} (force the current goal to
fail). Leaving it a variable is identical to \const{continue}.

Together with the predicates described in \secref{debugger}
and the other predicates of this chapter this predicate enables the
Prolog user to define a complete new debugger in Prolog. Besides this it
enables the Prolog programmer monitor the execution of a program. The
example below records all goals trapped by the tracer in the database.

\begin{code}
prolog_trace_interception(Port, Frame, _PC, continue) :-
        prolog_frame_attribute(Frame, goal, Goal), 
        prolog_frame_attribute(Frame, level, Level), 
        recordz(trace, trace(Port, Level, Goal)).
\end{code}

To trace the execution of `go' this way the following query should be
given:

\begin{code}
?- trace, go, notrace.
\end{code}

    \predicate{prolog_skip_level}{2}{-Old, +New}
Unify \arg{Old} with the old value of `skip level' and than set this
level according to \arg{New}.  New is an integer, or the special atom
\const{very_deep} (meaning don't skip).  The `skip level' is a global
variable of the Prolog system that disables the debugger on all
recursion levels deeper than the level of the variable.  Used to
implement the trace options `skip' (sets skip level to the level of the
frame) and `up' (sets skip level to the level of the parent frame (i.e.,
the level of this frame minus 1).
\end{description}


\section{Hooks using the exception/3 predicate}	\label{sec:exception3}

This section describes the predicate exception/3, which may be defined
by the user in the module \module{user} as a multifile predicate. Unlike
the name suggests, this is actually a \jargon{hook} predicate.
Exceptions are handled by the ISO predicates catch/3 and throw/1.  They
all frames created after the matching catch/3 to be discarded
immediately.

The predicate exception/3 is called by the kernel on a couple of events,
allowing the user to alter the behaviour on some predefined events.

\begin{description}
    \predicate{exception}{3}{+Exception, +Context, -Action}
Dynamic predicate, normally not defined. Called by the Prolog system on
run-time exceptions that can be repaired `just in time'. Currently
exception/3 is only used for trapping undefined predicates. The values
for \arg{Exception} are described below.  See also catch/3 and throw/1.

\begin{description}
    \termitem{undefined_predicate}{}
If \arg{Exception} is \const{undefined_predicate} \arg{Context} is
instantiated to a term \arg{Name}/\arg{Arity}. \arg{Name} refers to the
name and \arg{Arity} to the arity of the undefined predicate. If the
definition module of the predicate is not \arg{user}, \arg{Context} will
be of the form \mbox{\tt <Module>:<Name>/<Arity>}. If the predicate
fails Prolog will generate an \except{esistence_error} exception. If the
predicate succeeds it should instantiate the last argument either to the
atom \const{fail} to tell Prolog to fail the predicate, the atom
\const{retry} to tell Prolog to retry the predicate or \const{error} to
make the system generate an exception. The action \const{retry} only
makes sense if the exception handler has defined the predicate.
\end{description}
\end{description}


\section{Hooks for integrating libraries}	\label{sec:intlibs}

Some libraries realise an entirely new programming paradigm on top of
Prolog.  An example is XPCE which adds an object-system to Prolog as
well as an extensive set of graphical primitives.  SWI-Prolog provides
several hooks to improve the integration of such libraries.  See also
\secref{listing} for editing hooks and \secref{printmsg} for hooking
into the message system.

\begin{description}
    \predicate{prolog_list_goal}{1}{:Goal}
Hook, normally not defined. This hook is called by the 'L' command of
the tracer in the module \module{user} to list the currently called
predicate. This hook may be defined to list only relevant clauses of the
indicated \arg{Goal} and/or show the actual source-code in an editor.
See also portray/1 and multifile/1.

    \predicate{prolog:debug_control_hook}{1}{:Action}
Hook for the debugger-control predicates that allows the creator of
more high-level programming languages to use the common front-end
predicates to control de debugger.  For example, XPCE uses these hooks
to allow for spying methods rather then predicates. \arg{Action} is one
of:

\begin{description}
    \termitem{spy}{Spec}
Hook in spy/1.  If the hook succeeds spy/1 takes no further action.
    \termitem{nospy}{Spec}
Hook in nospy/1.  If the hook succeeds spy/1 takes no further action.
If spy/1 is hooked, it is advised to place a complementary hook for
nospy/1.
    \termitem{nospyall}{}
Hook in nospyall/0.  Should remove all spy-points.  This hook is
called in a failure-driven loop.
    \termitem{debugging}{}
Hook in debugging/0.  It can be used in two ways.  It can report
the status of the additional debug-points controlled by the above
hooks and fail to let the system report the others or it succeed,
overruling the entire behaviour of debugging/0.
\end{description}

    \predicate{prolog:help_hook}{1}{+Action}
Hook into help/0 and help/1.  If the hook succeeds, the built-in actions
are not executed. For example, \exam{?- help(picture).} is caught by the
XPCE help-hook to give help on the class {\em picture}.  Defined actions
are:

\begin{description}
    \termitem{help}{}
User entered plain help/0 to give default help.  The default performs
\exam{help(help/1)}, giving help on help.
    \termitem{help}{What}
Hook in help/1 on the topic \arg{What}.
    \termitem{apropos}{What}
Hook in apropos/1 on the topic \arg{What}.
\end{description}
\end{description}


\section{Hooks for loading files}	\label{sec:loadfilehook}

All loading of source-files is achieved by load_files/2.  The hook
prolog_load_file/2 can be used to load Prolog code from non-files
or even load entirely different information, such as foreign files.

\begin{description}
    \predicate{user:prolog_load_file}{2}{+Spec, +Options}
Load a single object.  If this call succeeds, load_files/2 assumes the
action has been taken care of. This hook is only called if \arg{Options}
does not contain the \term{stream}{Input} option.

The \pllib{http_load} provides an example, loading Prolog sources
directly from an HTTP server.
\end{description}


\section{Readline Interaction}		\label{sec:readline}

The following predicates are available if
\exam{current_prolog_flag(readline, true)} succeeds. They allow for
direct interaction with the GNU readline library. See also
\manref{readline}{3}

\begin{description}
    \predicate{rl_read_init_file}{1}{+File}
Read a readline initialisation file.  Readline by default reads
\file{~/.inputrc}.  This predicate may be used to read alternative
readline initialisation files.
    \predicate{rl_add_history}{1}{+Line}
Add a line to the Control-P/Control-N history system of the readline library.
\end{description}
