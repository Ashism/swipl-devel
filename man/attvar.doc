\chapter{Attributed variables}			\label{sec:attvar}

\begin{description}
    \predicate{attvar}{1}{{@}Term}
Succeeds if \arg{Term} is an attributed variable. Note that var/1 also
succeeds on attributed variables.  Attributed variables are created with
put_attr/3.

    \predicate{put_attr}{3}{+Var, +Name, +Value}
If \arg{Var} is a variable or attributed variable, set the value for the
attribute named \arg{Name} to \arg{Value}. If an attribute with this
name is already associated with \var{Var}, the old value is replaced.
Backtracking will restore the old value (i.e.\ an attribute is a mutable
term. See also set_arg/3). This predicate raises a type error if
\arg{Var} is not a variable or \arg{Name} is not an atom.

    \predicate{get_attr}{3}{+Var, +Name, -Value}
Request the current \arg{value} for the attribute named \arg{Name}.  If
\arg{Var} is not an attributed variable or the named attribute is not
associated to \arg{Var} this predicate fails silently.  If \arg{Name}
is not an atom, a type error is raised.

    \predicate{del_attr}{2}{+Var, +Name}
Delete the named attribute.  If \arg{Var} looses its last attribute it
is transformed back into a traditional Prolog variable.  If \arg{Name}
is not an atom, a type error is raised. In all other cases this
predicate succeeds regarless whether or not the named attribute is
present.
\end{description}


\section{Corouting}				\label{sec:corouting}

\begin{description}
    \predicate{freeze}{2}{+Var, :Goal}
Delay the execution of \arg{Goal} until \arg{Var} is bound (i.e. is
not a variable or attributed variable).	 If \arg{Var} is bound on entry
freeze/2 is equivalent to call/1.
\end{description}


\section{Global variables}			\label{sec:gvar}

Global variables are associations between names (atoms) and terms living
on the global stack. They come in two flavours. \jargon{Backtrackable}
global variables as implemented by b_setval/2 and b_getval/2 have the
same semantics as compound term argument using setarg/3: normal Prolog
terms can be assigned and backtracking reverses the assignment.  They
avoid the requirement to pass variables around in all intermediate
predicates.  \jargon{Non-backtrackable} global variables are also
associations between atoms and terms, but the assignment is retained
over backtracking. Unifications performed on parts (\emph{inside}) the
value however adhere to the normal backtracking rules. This applies
to assignment \emph{after} the nb_setval/2 call, but also to assignment
\emph{before} this call as illustrated by the following program:

\begin{code}
demo_nb_setval :-
	T = nice(N),
	(   N = world,
	    nb_setval(myvar, T),
	    fail
	;   nb_getval(myvar, V),
	    writeln(V)
	).
\end{code}

\begin{code}
?- demo_nb_setval.
nice(_G283)

Yes
\end{code}

In multi-threaded execution, both flavours of global variables are
strickly local to the calling thread.  The two flavours of attributed
variables have their own namespace and therefore an atom may both
have a backtrackable and non-backtrackable value associated.

\begin{description}
    \predicate{b_setval}{2}{+Name, +Value}
Associate the term \arg{Value} with the atom \arg{Name} or replaces
the currently associated value with \arg{Value}.  On backtracking the
modifications are reversed, which implies that the variable gets its
old value or ceases to exist.

    \predicate{b_getval}{2}{+Name, -Value}
Get the value associated with the backtrackable global variable
\arg{Name} and unify it with \arg{Value}.  Note that this unification
may further instantiate the value of the global variable.  If this
is undesirable the normal precautions (double negation or copy_term/2)
must be taken.
\end{description}

\begin{description}
    \predicate{nb_setval}{2}{+Name, +Value}
Associates \arg{Value} with the atom \arg{Name}.

    \predicate{nb_getval}{2}{+Name, -Value}
Unify \arg{Value} with the non-backtrackable value associated to
\arg{Name}.
\end{description}
